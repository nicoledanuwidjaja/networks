#!/usr/bin/env python

import sys, socket, select, time, json, random, math

# TODO: im confused about when to send 'fail' responses to clients
# TODO: when do we update our own CURRENT_TERM

# seemed like a class approach would be nicer to store all the state stuff!
class RaftServer:
	def __init__(self):
		self.my_id = sys.argv[1] # Your ID number
		self.replica_ids = sys.argv[2:] # The ID numbers of all the other replicas

		# Connect to the network. All messages to/from other replicas and clients will
		# occur over this socket
		self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		self.sock.connect(self.my_id)

		self.last = 0
		# I MADE LAST LOG INDEX = LAST_APPLIED BUT IDK IF IT SHOULD BE THIS OR COMMIT_INDEX
		# Nicole: Edit, I think it's commit index
		# Michelle: alrighty i changed it all to COMMIT_INDEX

		########################################################
		# STATE VARIABLES
		########################################################

		### PERSISTENT STATE ON ALL SERVERS
		# (Updated on stable storage before responding to RPCs)
		# latest term server has seen (initialized to 0
		# on first boot, increases monotonically)
		self.CURRENT_TERM = 0
		# candidateId that received vote in current
		# term (or null if none)
		self.VOTED_FOR = None
		# log entries; each entry contains command
		# for state machine, and term when entry
		# was received by leader (first index is 1)
		self.LOG = [] # { (index, term, command ***the command should be the msg sent by client to leader,
		# so followers can also update their KEY_VALUE dictionary) }

		### VOLATILE STATE ON ALL SERVERS
		# index of highest log entry known to be
		# committed (initialized to 0, increases
		# monotonically)
		self.COMMIT_INDEX = 0
		# index of highest log entry applied to state
		# machine (initialized to 0, increases
		# monotonically)
		self.LAST_APPLIED = 0

		### VOLATILE STATE ON LEADERS
		# (reinitialized after election)
		# for each server, index of the next log entry
		# to send to that server (initialized to leader
		# last log index (commit index) + 1)
		self.NEXT_INDEX = {} # { server : next_index }
		# for each server, index of highest log entry
		# known to be replicated on server
		# (initialized to 0, increases monotonically)
		self.MATCH_INDEX = {} # { server : match_index }

		# EXTRA GLOBAL VARIABLES WE MIGHT NEED
		# leader id
		self.LEADER_ID = "FFFF" # default
		self.STATUS = {} # STATUS = {'isLeader': False, 'status': 'follower', 'votes': 0}
		self.PREV_LOG_INDEX = 0 # index of log entry preceding new ones
		self.PREV_LOG_TERM = 0 # term of prev_log_index entry
		self.LAST_UPDATED_TIME = time.time() # Nicole: i added this for timeout purposes
		self.KEY_VALUE = {} # a dictionary containing the key/value pairs from clients, Section 5.3
		self.NUM_SUCCESSES = 0 # to keep track of if enough replicas replicated entry, so leader can apply entry to state machine
		# ELECTION VARIABLES
		self.ELECTION_TIMEOUT = random.randrange(150, 300) # 150-300 ms range per timeout
		#######################################################

		QUORUM = math.ceil(len(self.replica_ids) / 2)

		# check if election timeout has occurred
		def electionTimeout():
			return (time.time() - self.LAST_UPDATED_TIME) > self.ELECTION_TIMEOUT

		# initializes status of a server
		def initializeServer():
			self.STATUS = {'isLeader': False, 'status': 'follower', 'votes': 0}

		# begins the election (vote for myself and send requestVote RPC to all other servers)
		def beginElection():
			# TODOOOOOOO
			self.STATUS['votes'] = 1
			self.CURRENT_TERM = self.CURRENT_TERM + 1
			self.STATUS['status'] = 'candidate'
			self.LAST_UPDATED_TIME = time.time()
			sendRequestVoteRPCs()

		# LEADER
		# if last log index >= nextIndex for a follower: send AppendEntriesRPC with
		# log entries starting at nextIndex
		# TODO: i think i was wrong and we just need to send it once and it gets "sent in parallel"
		def sendAppendEntriesRPC():
			append_entries = {'term': self.CURRENT_TERM, 'leaderId': self.LEADER_ID,
							  'prevLogIndex': self.PREV_LOG_INDEX, 'prevLogTerm': self.PREV_LOG_TERM,
							  'entries': self.LOG[self.NEXT_INDEX:], 'leaderCommit': self.COMMIT_INDEX}
			sendDict(append_entries)
			# for rid in self.replica_ids:
			# 	# TODO (VERY UNSURE)
			# 	# we should be able to get the status type from the rid and check if follower
			# 	if self.LAST_APPLIED > self.NEXT_INDEX[rid]:
			# 		append_entries = {'term': self.CURRENT_TERM, 'leaderId': self.LEADER_ID, 'prevLogIndex': self.PREV_LOG_INDEX, 'prevLogTerm': self.PREV_LOG_TERM, 'entries': self.LOG[self.NEXT_INDEX:], 'leaderCommit': self.COMMIT_INDEX}
			# 		sendDict(append_entries)

		# FOLLOWER
		def recvAppendEntriesRPC(msg):
			if msg['term'] >= self.CURRENT_TERM and self.PREV_LOG_INDEX == msg['prevLogIndex'] and self.PREV_LOG_TERM == msg['prevLogTerm']:
				if not msg['entries']:
					self.LEADER_ID = msg['leaderId']
					self.STATUS['status'] = "follower"
					self.STATUS['isLeader'] = False
					self.STATUS['votes'] = 0
				successful = updateLogFollower(msg)
				updateCommitIndex(msg)
				response = {'term': self.CURRENT_TERM, 'success': successful}

		# FOLLOWER
		#  If an existing entry conflicts with a new one (same index
		# but different terms), delete the existing entry and all that
		# follow it (5.3)
		# Append any new entries not already in the log
		# msg = AppendEntriesRPC
		# return whether to respond success or not
		def updateLogFollower(msg):
			idx = msg['prevLogIndex']
			self.LOG = self.LOG[:idx]
			self.LOG.extend(msg['entries'])
			for e in msg['entries']:
				if e['command']['type'] == 'put':
					updateKeyValue(e['command'])
			if self.LOG[idx]['term'] != msg['prevLogTerm']:
				return False
			else:
				return True


		# LEADER
		# update log after receving a command from a client
		# msg = client request
		def updateLogLeader(msg):
			self.LOG.append({'index': self.NEXT_INDEX, 'term': self.CURRENT_TERM, 'command': msg})

		# LEADER
		# handle responses to my appendEntriesRPC (if i am leader)
		# If enough messages have now been received as successful, can commit the entry
		# else just increment the NUM_SUCCESSES
		# else if the response was a fail, then resend the AppendEntriesRPC
		def appendEntriesRPCHandleResult(msg):
			if msg['success']:
				self.NUM_SUCCESSES += 1
				if self.NUM_SUCCESSES >= QUORUM:
					self.NUM_SUCCESSES = 0
					updateCommitIndex(msg)
					okGet(self.LOG[self.LAST_APPLIED]['command'])
			else:
				self.NEXT_INDEX -=1
				sendAppendEntriesRPC()

		# FOLLOWER: making sure that my COMMIT_INDEX is as great as the leader's
		# LEADER: updating my COMMIT_INDEX after receiving quorum of successful replica responses
		def updateCommitIndex(msg):
			if msg['leaderCommit'] > self.COMMIT_INDEX :
				# update my own COMMIT_INDEX
				self.COMMIT_INDEX = min(msg['leaderCommit'], self.LAST_APPLIED)

		# sends RequestVoteRPCs to all servers
		def sendRequestVoteRPCs():
			# if the vote is in 'term' and is for the 'candidateId', then we sendDict
			request_vote = {'term': self.CURRENT_TERM, 'candidateId': self.my_id, 'lastLogIndex': self.LAST_COMMITED, 'lastLogTerm': self.LOG[self.LAST_COMMITED]['term']}
			sendDict(request_vote)

		# receive RequestVoteRPCs from other servers
		def recvRequestVoteRPCs(msg):
			candidate_term = msg['term']
			# Reply false if term < currentTerm (5.1)
			if candidate_term < self.CURRENT_TERM:
				response = {'term': self.CURRENT_TERM, 'voteGranted': False}

			elif not self.VOTED_FOR or self.VOTED_FOR == msg['candidateId'] and msg['lastLogIndex'] >= self.LAST_COMMITED and msg['lastLogTerm'] >= self.LOG[self.LAST_COMMITED]['term']:
				response = {'term': candidate_term, 'voteGranted': True}
				self.VOTED_FOR = msg['candidateId']
			else:
				# not sure if we're supposed to be sending a response still, but that's what I'm doing for now
				response = {'term': self.CURRENT_TERM, 'voteGranted': False}
			sendDict(response)

		# handle response from other servers of my RequestVoteRPC
		def requestVoteRPCHandleResult(msg):
			if msg['voteGranted']:
				self.STATUS['votes']+=1

			if self.STATUS['votes'] >= QUORUM:
				self.STATUS['isLeader'] = True
				self.STATUS['status'] = 'leader'
				reinitializeLeaderStates()
				broadcastHeartbeat()

		# reinitialize global variable states for leaders
		def reinitializeLeaderStates():
			for rid in self.replica_ids:
				self.NEXT_INDEX[rid] = self.LAST_COMMITED + 1
				self.MATCH_INDEX[rid] = 0

		# LEADER
		# send empty AppendEntriesRPC to all servers
		# 1) used to establish its authority and prevent new elections upon winning an election
		# 2) used to maintain leadership to prevent election timeouts
		def broadcastHeartbeat():
			append_entries = {'term': self.CURRENT_TERM, 'leaderId': self.my_id, 'prevLogIndex': self.PREV_LOG_INDEX,
							  'prevLogTerm': self.LOG[self.PREV_LOG_INDEX]['term'], 'entries': [], 'leaderCommit': self.COMMIT_INDEX}
			sendDict(append_entries)

		# return associated value with given key if it exists, else return an empty string
		# TODO: this is for "If the client issues a get() for a key that has does not exist (i.e. it was never put()), your datastore should return an empty value (i.e. an empty string)."
		# in the project description
		def findVal(key):
			val = self.KEY_VALUE.get(key) # what is this?
			return val if val else ""

		# update KEY_VALUE dictionary
		def updateKeyValue(msg):
			self.KEY_VALUE[msg['key']] = msg['value']

		# turn given dictionary into json, and send through socket
		def sendDict(msg):
			msgjson = json.dumps(msg)
			print(msgjson)
			self.sock.sendall(msgjson)

		# GET MSG
		# {"src": "<ID>", "dst": "<ID>", "leader": "<ID>", "type": "get", "MID": "<a unique string>",
		# "key": "<some key>"}

		def handleGetMsg(msg):
			# FOLLOWER
			if not self.STATUS['isLeader']:
				redirect(msg)
			# LEADER
			# else if notFailed(): # TODO: confused about when one would fail tho
			else:
				updateLogLeader(msg)
				sendAppendEntriesRPC()

		# LEADER
		# OK GET MSG
		def okGet(msg):
			ok = {"src": msg['dst'], "dst": msg['src'], "leader": self.LEADER_ID, "type": "ok", "MID": msg['MID'],
				  "value": findVal(msg['key'])}
			sendDict(ok)

		# LEADER
		# FAIL GET MSG
		def failGet(msg):
			fail = {"src": msg['dst'], "dst": msg['src'], "leader": self.LEADER_ID, "type": "fail", "MID": msg['MID']}
			sendDict(fail)

		# PUT MSG
		# {"src": "<ID>", "dst": "<ID>", "leader": "<ID>", "type": "put", "MID": "<a unique string>",
		# "key": "<some key>", "value": "<value of the key>"}

		def handlePutMsg():
			# FOLLOWER
			if not self.STATUS['isLeader']:
				redirect(msg)
			# LEADER
			# else if notFailed(): # TODO: confused about when one would fail tho
			else:
				updateLogLeader(msg)
				updateKeyValue(msg)
				sendAppendEntriesRPC()

		# LEADER
		# OK PUT MSG
		def okPut(msg):
			ok = {"src": msg['dst'], "dst": msg['src'], "leader": self.LEADER_ID, "type": "ok", "MID": msg['MID']}
			sendDict(ok)

		# LEADER
		# FAIL PUT MSG
		def failPut(msg):
			fail = {"src": msg['dst'], "dst": msg['src'], "leader": self.LEADER_ID, "type": "fail", "MID": msg['MID']}
			sendDict(fail)

		# FOLLOWER
		# REDIRECT MSG
		def redirect(msg):
			redir = {"src": msg['dst'], "dst": msg['src'], "leader": self.LEADER_ID, "type": "redirect", "MID": msg['MID']}
			sendDict(redir)



		# THE 2 METHODS BELOW: literally implmenenting the All Servers section of the Rules for Servers in RAFT protocol

		# If RPC request or response contains term T > currentTerm:
		# set currentTerm = T, convert to follower (5.1)
		def termCheck(msg):
			if msg['term'] > self.CURRENT_TERM:
				self.CURRENT_TERM = msg['term']
				self.STATUS['status'] = 'follower'
				self.STATUS['isLeader'] = False

		# If commitIndex > lastApplied: increment lastApplied, apply
		# log[lastApplied] to state machine (5.3)
		def compareCommitAndApplied():
			if self.COMMIT_INDEX > self.LAST_APPLIED:
				self.LAST_APPLIED += 1
				# "apply log[lastApplied] to state machine"
				self.COMMIT_INDEX  = self.LAST_APPLIED

		# implementing RAFT election protocol

		# remote procedure calls
		# REQUEST VOTE: initiated by candidates during elections
		# APPEND ENTRIES:  initiated by leaders to replicate log entries and to provide a form of heartbeat
		# ** Servers retry RPCs if they do not receive a response in a timely manner, and they issue RPCs in parallel
		# for best performance. **

		while True:
			ready = select.select([self.sock], [], [], 0.1)[0]

			if self.sock in ready:
				msg_raw = self.sock.recv(32768)

				if electionTimeout():
					beginElection()

				# first check if my COMMIT_INDEX and LAST_APPLIED are in sync
				compareCommitAndApplied()

				if len(msg_raw) == 0: continue
				msg = json.loads(msg_raw)

				# CLIENT MSGS
				if msg['type'] in 'get' or msg['type'] in 'put':
					# if I am leader and client sent a "get" msg
					if self.STATUS['isLeader'] and msg['type'] in 'get':
						handleGetMsg(msg)
					# if I am leader and client sent a "put" msg
					elif self.STATUS['isLeader'] and msg['type'] in 'put':
						handlePutMsg(msg)
					# if I am leader and client sent a "get" or "put" msg
					elif not self.STATUS['isLeader'] and msg['type'] in 'get' or msg['type'] in 'put':
						redirect(msg)

				# MSGS FROM OTHER SERVERS
				else:
					# first do a term check to see I have right term
					termCheck(msg)
					# if I receive a RequestVoteRPC from another server
					if 'candidateId' in msg:
						recvRequestVoteRPCs(msg)
					# if I receive a response to one of my RequestVoteRPCs
					elif 'voteGranted' in msg:
						requestVoteRPCHandleResult(msg)
					# if I receive an AppendEntriesRPC
					elif 'leaderCommit' in msg:
						recvAppendEntriesRPC(msg)
					# if I receive a response to one of my AppendEntriesRPCs
					elif 'success' in msg:
						appendEntriesRPCHandleResult(msg)

			# 	# Handle noop messages. This may be removed from your final implementation
			# 	elif msg['type'] == 'noop':
			# 		print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
			#
			# clock = time.time()
			# if clock-last > 2:
			# 	# Send a no-op message to a random peer every two seconds, just for fun
			# 	# You definitely want to remove this from your implementation
			# 	msg = {'src': self.my_id, 'dst': random.choice(self.replica_ids), 'leader': 'FFFF', 'type': 'noop'}
			# 	self.sock.send(json.dumps(msg))
			# 	print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
			# 	last = clock
