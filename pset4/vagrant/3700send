#!/usr/bin/python3 -u
# Usage: ./3700send <recv_host>:<recv_port>
import sys
import struct
import socket
import time
import datetime
import select
import json

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 5
SEQUENCE = 0

# global storage
DATA = {}
send_time = datetime.datetime.now()
rec_time = datetime.datetime.now()
retry_time = datetime.datetime.now()
RTT = 0
RTO = 0

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":") + 1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)

# TODO: HANDLE REORDERED PACKETS
# TODO: HANDLE DROPPED PACKETS

# LOST SEGMENTS SHOULD BE HANDLED BY SENDER
# use timeout to detect missing ACKs
# need to estimate RTT to calibrate the timeout

# UTILIZING SEQUENCE #'S
# out of order packets are reordered or dropped
# missing sequence numbers indicate lost packets

# TODO: IMPLEMENT RTT/RTP
# RTT (Round Trip Time) = time to send data + time to receive ACK
# has to do with using the time stamps
# - Store the time packet is sent and time ACK received and do calculations for old/new rtt

# new_rtt = α (old_rtt) + (1 – α)(new_sample)
# Recommended α: 0.8-0.9 (0.875 for most TCPs)
# RTO = 2 * new_rtt (i.e. TCP is conservative)
# KARN'S ALGORITHM: ignore samples for retransmitted segments when calculating RTT

# add to data array when sending a new data package
def addToData(data):
    # the ack expected if this data is received
    expectedAck = SEQUENCE + DATA_SIZE
    DATA[expectedAck] = data


# delete from data array when received ack for that data package
def deleteFromData(ack):
    del DATA[ack]

# TODO
# update sample when finished transmission
def updateRTT():
    global RTT
    new_sample = (rec_time - send_time).total_seconds()
    alpha = 0.875
    RTT = (alpha * RTT) + (1 - alpha)*new_sample

# update retransmission time out after every round trip
def updateRTO():
    global RTO
    RTO = RTT * 2


# update retransmission time???
# def updateRetry():



# updates the sequence number so that the receiver and sender can keep track of appropriate sequence of packets
def updateSequence(ack_num):
    global SEQUENCE
    SEQUENCE = ack_num


def updatePacket(msg):
    global PREVPACKET
    PREVPACKET = msg


# retransmits a package that we haven't received an ACK for yet
def retransmit():
    global DATA
    msg = DATA[SEQUENCE + DATA_SIZE]
    sock.sendto(msg, dest)


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " SENDER: " + string + "\n")


def send_next_packet():
    global SEQUENCE
    global send_time
    data = sys.stdin.buffer.read(DATA_SIZE)

    if len(data) > 0:
        # log("DATA FROM BUFFER: " + str(data))
        # create struct for passing packet header data (10 bytes)
        header_format = (SEQUENCE, 0, False, False)
        header_struct = struct.Struct('I I ? ?')
        header = header_struct.pack(*header_format)

        msg = bytearray()
        msg.extend(header)
        log("LINE 44 HEADER: " + str(header))
        msg.extend(data)
        # log("MESSAGE: " + str(msg))

        # ADD MSG TO DATA DICT
        addToData(msg)

        # checks if the current message size is the same
        if sock.sendto(msg, dest) < len(msg):
            log("[error] unable to fully send packet")
        else:
            send_time = datetime.datetime.now()
            log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
        return True
    else:
        # header_format = (SEQUENCE, 0, False, True)
        # header_struct = struct.Struct('I I ? ?')
        # header = header_struct.pack(*header_format)
        # msg = bytearray()
        # msg.extend(header)
        # sock.sendto(msg, dest)
        # log('[completed]')
        # sys.exit(0)
        return False


# Send first packet
send_next_packet()

# Now read in data, send packets
while True:
    log("ABOUT TO SLEEP")
    result = sock.recvfrom(MSG_SIZE)
    if result:
        (received, addr) = result
        # log(str(received))
        try:
            # receive new ack number from client
            rec_time = datetime.datetime.now()

            # RTT sample retransmissions
            updateRTT()
            log("[RTT]" + str(RTT))
            updateRTO()
            log("[RTO]" + str(RTO))
            # updateRetry()
            # log("[RETRY TIME]" + str(retry_time))

            ack_num = int.from_bytes(received, byteorder='big')
            # what the most recently sent seq num should be ACCORDING to the ack_num
            prev_seq = ack_num - 1000
            log("RECEIVED ACK: " + str(ack_num))

            # DELETE FROM DATA DICT IF CORRESPONDING ACK IS RECEIVED
            deleteFromData(ack_num)

            # If there is an ack, send next packet
            if prev_seq == SEQUENCE:
                # update SEQUENCE to be the ACK the recv returned
                updateSequence(ack_num)
                # Try to send next packet; break if no more data
                if not send_next_packet():
                    break
        except (ValueError, KeyError, TypeError):
            log("[recv corrupt packet]")
    else:
        curr_time = datetime.datetime.now()
        secs_elapsed = (curr_time - send_time).total_seconds()
        if secs_elapsed > RTO:
            # TODO: Use timeout to detect lost packets instead of just exiting
            retransmit()
            # log("[error] timeout")
        # retry
        # sys.exit(-1)

header_format = (SEQUENCE, 0, False, True)
header_struct = struct.Struct('I I ? ?')
header = header_struct.pack(*header_format)
msg = bytearray()
msg.extend(header)
sock.sendto(msg, dest)
log('[completed]')

#
# # create struct for passing packet header data (10 bytes)
# # (sequence, window, ack, eof)
# header_format = (SEQUENCE, 0, False, False)
# header_struct = struct.Struct('I I ? ?')
# header = header_struct.pack(*header_format)
#
# # message contains no besides end packet (?? is this right)
# msg = bytearray()
# msg.extend(header)
# log("LINE 95 HEADER: " + str(header))
# sock.sendto(msg, dest)
# sys.exit(0)