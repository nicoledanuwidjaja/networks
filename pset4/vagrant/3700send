#!/usr/bin/python3 -u
# Usage: ./3700send <recv_host>:<recv_port>
import sys
import struct
import socket
import time
import datetime
import select

# TODO: MAYBE GET RID OF WINDOW AND ACK FOR PART OF HEADER
# CUZ WE NEVER USE IT
# OK, DONE MICHELLE :)
# LOOOL THANK U >.<

# TODO: okay so like the testall with delay and duplicates
# applied are failing now. But since the code is faster i didn't wanna
# change it back to what we had before esp since u implemented select and
# everything too so I was trying to figure out why it wont work
# but i have no idea so instead I just implemented the reordering stuff
# (saving data we get out of order till we can get rid of it and etc)
# and added print statements D:
# ill try working on some tomorrow but i dunno D: i feel v discouraged rn this
# project is draining my happiness and life force

# TODO: HANDLE DUPLICATED ACKS
# TODO: HANDLE REORDERED ACKS
# out of order packets are reordered or dropped
# TODO: HANDLE DROPPED ACKS
# use timeout to detect missing ACKs
# missing sequence numbers indicate lost packets
# TODO: HANDLE DELAYED ACKS

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 5
SEQUENCE = 0

# global storage
DATA = {}
# only updated when a NEW transmission is sent
send_time = datetime.datetime.now()
rec_time = datetime.datetime.now()
last_sent = datetime.datetime.now()
RTT = 0  # round trip time
RTO = 0  # retransmission time out
SAVED_ACKS = []

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":") + 1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)

# communication channels
inputs = [sock]
outputs = []


# calculate new sample of round trip time to adjust retransmission time out
def calculateRTT():
    global RTT
    new_sample = (rec_time - send_time).total_seconds()
    alpha = 0.875
    RTT = (alpha * RTT) + (1 - alpha) * new_sample


# update retransmission time out by first updated RTT then getting the
# RTO from that new RTT sample
# SHOULD ONLY BE CALLED ON PACKETS NOT BEING RETRANSMITTED
def updateRTO():
    global RTO
    global RTT
    calculateRTT()
    RTO = RTT * 2


# updates the sequence number so the sequence # equals
# the last received ack / the sequence # of the next datagram to send
def updateSequence(ack_num):
    global SEQUENCE
    SEQUENCE = ack_num


# add to data array when sending a new data package
# key = expected ACK if corresponding datagram is received
def addToData(data):
    global SEQUENCE
    global DATA_SIZE
    # the ack expected if this data is received
    expectedAck = SEQUENCE + DATA_SIZE
    DATA[expectedAck] = data


# delete from data array once we received the ack for that data package
def deleteFromData(ack):
    global DATA
    if ack in DATA:
        del DATA[ack]


# retransmit a data package because sender timed out for an ACK response
def retransmit():
    global DATA
    global SEQUENCE
    global DATA_SIZE
    # get the data of the ACK that we were expecting (but didn't get)
    msg = DATA[SEQUENCE + DATA_SIZE]
    sock.sendto(msg, dest)


def filterSavedAcks():
    global SAVED_ACKS
    global SEQUENCE
    while SEQUENCE in SAVED_ACKS:
        SAVED_ACKS.remove(SEQUENCE)
        updateSequence(SEQUENCE + 1000)

# print statement
def log(string):
    sys.stderr.write("[" + datetime.datetime.now().strftime("%H:%M:%S.%f") + "]" + " SENDER: " + string + "\n")


# sends the next packet to recv
def send_next_packet():
    global SEQUENCE
    global send_time
    global DATA_SIZE

    data = sys.stdin.buffer.read(DATA_SIZE)
    # there is more data to be sent to recv
    if len(data) > 0:
        # make header
        header_format = (SEQUENCE, False)
        header_struct = struct.Struct('I ?')
        header = header_struct.pack(*header_format)

        # make datagram
        msg = bytearray()
        msg.extend(header)
        msg.extend(data)

        # add msg to data dict
        addToData(msg)

        # send the datagram
        sock.sendto(msg, dest)

        # update the send_time to correspond to now
        # since we just sent a datagram
        send_time = datetime.datetime.now()
        log("NEXT PACKET HAS BEEN SENT")

        # this is not the last packet
        return True
    # there is no more data to be sent to recv
    else:
        # send final datagram indicating EOF
        # make header
        header_format = (SEQUENCE, True)
        header_struct = struct.Struct('I ?')
        header = header_struct.pack(*header_format)

        # make datagram
        msg = bytearray()
        msg.extend(header)

        # send the datagram
        sock.sendto(msg, dest)
        log("LAST PACKET HAS BEEN SENT")

        # this is the last packet
        return False


# send the first packet
send_next_packet()

# Now continuously read in data and send packets
while inputs:
    curr_time = datetime.datetime.now()

    # how much time as elapsed since the last datagram was sent?
    secs_elapsed = (curr_time - last_sent).total_seconds()

    # TODO: it times out on select
    # receive message from client socket
    reads, writes, errors = select.select(inputs, outputs, inputs)
    log("STARTING INPUTS")
    result = sock.recvfrom(MSG_SIZE)

    # if there is an ACK we received from the client
    if result:
        log("THERE IS STUFF TO BE RECEIVED FROM CLIENT")
        (received, addr) = result
        ack_num = int.from_bytes(received, byteorder='big')
        log("ACK_NUM: " + str(ack_num))
        log("SEQUENCE: " + str(SEQUENCE))
        # if ACK corresponds to the last sent datagram
        if SEQUENCE + DATA_SIZE == ack_num:
            log("THE STUFF IS NEXT IN ORDER")
            rec_time = datetime.datetime.now()
            updateRTO()
            deleteFromData(ack_num)
            updateSequence(ack_num)
            filterSavedAcks()
            if not send_next_packet():
                # sender is done sending
                log("[completed]")
                break
            # if we have already received this ACK
            # OR we have already passed this ACK (this should never happen)
            # OR we have not yet received this ACK
        elif SEQUENCE + DATA_SIZE > ack_num:
            # if (SEQUENCE + 1000 > ack_num) this is a duplicate (aka we've already received this ACK/ passed this ACK)
            # do nothing
            break
        elif SEQUENCE + DATA_SIZE < ack_num:
            log("ACKS ARE BEING RECEIVED OUT OF ORDER")
            # if (SEQUENCE < ack_num) the packets are being sent out of order
            # (CURRENTLY WE'RE DROPPING WRONGLY ORDERED PACKETS)
            # we are DROPPING anything that does not correspond to the last sent datagram
            # Nicole: Yup, but instead we should reorder them right? Idk how to do that
            # Should we store the misordered packets in a temporary storage and wait until we get the sequences in between?
            # Like: ack_num = 4, SEQ + DATA = 2, store 4 until 3 is reached, then send 4 after 3?
            # Like: ack_num = 3000, SEQ + DATA = 1000, oh well catch the 2000 one?
            SAVED_ACKS.append(ack_num)
            break
        else:
            log("THIS IS WHERE ITS TIMING OUT")

    # if we have NOT gotten a response from the client
    # AND it has been longer than RTO
    elif secs_elapsed > RTO:
        log("THERE IS NO STUFF TO BE RECEIVED :( AND RTO HAS HAPPENED")
        # retransmit the last sent datagram
        retransmit()
        log("RETRANSMITTED DATAGRAM")
        # change last_sent to be now since we just re-sent a datagram right now
        last_sent = datetime.datetime.now()