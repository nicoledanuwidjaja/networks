#!/usr/bin/python3 -u
# Usage: ./3700send <recv_host>:<recv_port>
import sys
import struct
import socket
import time
import datetime
import select

# TODO: MAYBE GET RID OF WINDOW AND ACK FOR PART OF HEADER
# CUZ WE NEVER USE IT
# OK, DONE MICHELLE :)

# TODO: HANDLE DUPLICATED ACKS
# TODO: HANDLE REORDERED ACKS
# out of order packets are reordered or dropped
# TODO: HANDLE DROPPED ACKS
# use timeout to detect missing ACKs
# missing sequence numbers indicate lost packets
# TODO: HANDLE DELAYED ACKS

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 5
SEQUENCE = 0

# global storage
DATA = {}
# only updated when a NEW transmission is sent
send_time = datetime.datetime.now()
rec_time = datetime.datetime.now()
last_sent = datetime.datetime.now()
RTT = 0  # round trip time
RTO = 0  # retransmission time out

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":") + 1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)


# calculate new sample of round trip time to adjust retransmission time out
def calculateRTT():
    global RTT
    new_sample = (rec_time - send_time).total_seconds()
    alpha = 0.875
    RTT = (alpha * RTT) + (1 - alpha) * new_sample


# update retransmission time out by first updated RTT then getting the
# RTO from that new RTT sample
# SHOULD ONLY BE CALLED ON PACKETS NOT BEING RETRANSMITTED
def updateRTO():
    global RTO
    calculateRTT()
    RTO = RTT * 2


# updates the sequence number so the sequence # equals
# the last received ack / the sequence # of the next datagram to send
def updateSequence(ack_num):
    global SEQUENCE
    SEQUENCE = ack_num


# add to data array when sending a new data package
# key = expected ACK if corresponding datagram is received
def addToData(data):
    # the ack expected if this data is received
    expectedAck = SEQUENCE + DATA_SIZE
    DATA[expectedAck] = data


# delete from data array once we received the ack for that data package
def deleteFromData(ack):
    del DATA[ack]


# retransmit a data package because sender timed out for an ACK response
def retransmit():
    global DATA
    # get the data of the ACK that we were exepcting (but didn't get)
    msg = DATA[SEQUENCE + DATA_SIZE]
    sock.sendto(msg, dest)


# print statement
def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " SENDER: " + string + "\n")


# sends the next packet to recv
def send_next_packet():
    global SEQUENCE
    global send_time
    data = sys.stdin.buffer.read(DATA_SIZE)
    # there is more data to be sent to recv
    if len(data) > 0:
        # make header
        header_format = (SEQUENCE, False)
        header_struct = struct.Struct('I ?')
        header = header_struct.pack(*header_format)

        # make datagram
        msg = bytearray()
        msg.extend(header)
        msg.extend(data)

        # add msg to data dict
        addToData(msg)

        # send the datagram
        sock.sendto(msg, dest)

        # update the send_time to correspond to now
        # since we just sent a datagram
        send_time = datetime.datetime.now()

        log("NEXT PACKET HAS BEEN SENT")

        # this is not the last packet
        return True

    # there is no more data to be sent to recv
    else:
        # send final datagram indicating EOF
        # make header
        header_format = (SEQUENCE, True)
        header_struct = struct.Struct('I ?')
        header = header_struct.pack(*header_format)

        # make datagram
        msg = bytearray()
        msg.extend(header)

        # send the datagram
        sock.sendto(msg, dest)

        log("LAST PACKET HAS BEEN SENT")

        # log that the program has ended
        log('[completed]')

        # this is the last packet
        return False


# send the first packet
send_next_packet()

# Now continuously read in data and send packets
while True:
    curr_time = datetime.datetime.now()

    # how much time as elapsed since the last datagram was sent?
    secs_elapsed = (curr_time - last_sent).total_seconds()

    result = sock.recvfrom(MSG_SIZE)

    # if there is an ACK we received from the client
    if result:
        log("THERE IS STUFF TO BE RECEIVED")
        (received, addr) = result
        ack_num = int.from_bytes(received, byteorder='big')
        # if ACK corresponds to the last sent datagram
        if SEQUENCE + DATA_SIZE == ack_num:
            log("THE STUFF IS NEXT IN ORDER")
            rec_time = datetime.datetime.now()
            updateRTO()
            deleteFromData(ack_num)
            updateSequence(ack_num)

            if not send_next_packet():
                break
            # if we have already received this ACK
            # OR we have already passed this ACK (this should never happen)
            # OR we have not yet received this ACK
            # TODO: I don't know what to do :(
            # do nothing,
        elif SEQUENCE + DATA_SIZE > ack_num:
            # if (SEQUENCE + 1000 > ack_num) this is a duplicate (aka we've already received this ACK/ passed this ACK)
            break
        elif SEQUENCE + DATA_SIZE < ack_num:
            # if (SEQUENCE < ack_num) the packets are being sent out of order
            # (CURRENTLY WE'RE DROPPING WRONGLY ORDERED PACKETS)
            # we are DROPPING anything that does not correspond to the last sent datagram
            # Nicole: Yup, but instead we should reorder them right? Idk how to do that
            # Should we store the misordered packets in a temporary storage and wait until we get the sequences in between?
            # Like: ack_num = 4, SEQ + DATA = 2, store 4 until 3 is reached, then send 4 after 3?
            # wait i think this is dumb
            break

    # if we have NOT gotten a response from the client
    # AND it has been longer than RTO
    elif secs_elapsed > RTO:
        log("THERE IS NO STUFF TO BE RECEIVED :( AND RTO HAS HAPPENED")
        # retransmit the last sent datagram
        retransmit()
        log("RETRANSMITTED DATAGRAM")
        # change last_sent to be now since we just re-sent a datagram right now
        last_sent = datetime.datetime.now()
