#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, math

# DEBUG = True
DEBUG = False

parser = argparse.ArgumentParser(description='route packets')
parser.add_argument('asn', type=int, help="AS Number")
parser.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
args = parser.parse_args()

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"

# received incoming data
messages = []
forwarding_table = []


##########################################################################################

# convert ip of neighbor to oldrouter (*.*.*.2 to *.*.*.1)
def neighborToRouterIP(neighbor):
    return '.'.join(neighbor.split('.')[:-1] + ["1"])


def ipToValue(ipl):
    return int("".join(ipl))


# convert ip address to binary representation of four 8-bit segments
def binl(ip):
    ipl = ip.split(".")
    binl = []
    for n in ipl:
        # turn into binary
        binip = bin(int(n))[2:]
        # add padding for 8-bit segments
        strip = str(binip).zfill(8)
        binl.append(strip)
    return binl


# calculate the combination for network/netmask addresses
def combine_submask(netmask_ip, dest_ip):
    # print("OG Netmask: ", netmask_ip)
    # print("OG Dest: ", dest_ip)
    combined = []
    # separate bits into four groups of 8-bits
    for b in range(4):
        # calculate bitwise and for each bit individually
        finpart = ""
        for s in range(8):
            finpart += str(int(netmask_ip[b][s]) & int(dest_ip[b][s]))
        # print("Part: ", finpart)
        combined.append(finpart)
    # print("Combined: ", combined)
    return combined


# match combined network/netmask addresses with corresponding neighbor network
def mask(dest):
    result = []
    # fake = ["192.168.0.0"]
    for e in forwarding_table:
        nmbinl = binl(e['netmask'])
        destbinl = binl(dest)
        # Test variables
        # nmbinl = binl("192.168.0.0")
        # destbinl = binl("255.255.255.0")
        subresult = combine_submask(nmbinl, destbinl)
        result.append(subresult)
    return result


# convert list of binary ips(in list form) to list of dec ips (in list form)
def ipl(binl):
    ipl = []
    for b in range(len(binl)):
        binp = []
        for p in range(4):
            binp.append(int(binl[b][p], 2))
        ipl.append(binp)
    return ipl


# see if a specific network matches a
# specific destination that has already been masked
def matchIps(networkipl, destipl):
    for i in range(4):
        if networkipl[i] == 0:
            return True
        elif networkipl[i] != destipl[i]:
            return False


# encodes dictionary as bytes in json format
def dictToByte(dictionary):
    dictj = json.dumps(dictionary)
    dictb = dictj.encode("utf-8")
    return dictb


# converts ip address string to integer list of size four
def ipToIntList(strl):
    return list(map(int, strl.split('.')))


# returns the length of the netmask
def countNetmask(nmstr):
    nmBin = binl(nmstr)
    count = 0
    for x in range(len(nmBin)):
        for y in nmBin[x]:
            if int(y) == 1:
                count += 1
    return count


class Router:
    routes = None
    updates = None
    relations = None
    sockets = None

    def __init__(self, networks):
        self.routes = []
        self.updates = []
        # {network IP of neighbor : the kind of neighbor they are (peer, prov, cust) }
        self.relations = {}
        # {network IP of neighbor : corresponding socket}
        self.sockets = {}
        for relationship in networks:
            network, relation = relationship.split("-")
            if DEBUG:
                print("Starting socket for", network, relation)
            self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sockets[network].setblocking(0)
            self.sockets[network].connect(network)
            self.relations[network] = relation
        return

    def remove_entries(self, msgs):
        """ Finds messages to be revoked and removes from forwarding table"""
        for entry in forwarding_table:
            for msg in msgs:
                if msg['network'] == entry['network'] and msg['netmask'] == entry['netmask']:
                    forwarding_table.remove(entry)

    def lookup_routes(self, daddr):
        """ Lookup all valid routes for an address """
        port = mask(daddr)
        resultdec = ipl(port)
        outroutes = []
        for i in range(len(port)):
            ipstr = forwarding_table[i]['network']
            if matchIps(ipToIntList(ipstr), resultdec[i]):
                outroutes.append(forwarding_table[i])
        return outroutes

    def get_shortest_as_path(self, routes):
        """ select the route with the shortest AS Path """
        outroutes = []
        # {length of AS Path : corresponding entry from forwarding table}
        pathCounts = {}
        for entry in routes:
            currPathLength = len(entry['msg']['ASPath'])
            pathCounts[currPathLength] = entry
        minPath = min(pathCounts.keys())

        for pathLength in pathCounts.keys():
            if pathLength == minPath:
                outroutes.append(pathCounts[pathLength])
        return outroutes

    def get_highest_preference(self, routes):
        """ select the route with the shortest AS Path """
        outroutes = []
        # {localPref : corresponding entry from forwarding table with that localPref #}
        prefRoutes = {}
        for entry in routes:
            localPref = entry['msg']['localpref']
            prefRoutes[localPref] = entry
        highestPref = max(prefRoutes.keys())
        for localpref in prefRoutes.keys():
            if localpref == highestPref:
                outroutes.append(prefRoutes[localpref])
        return outroutes

    def get_self_origin(self, routes):
        """ select self originating routes """
        outroutes = []
        for entry in routes:
            origin = entry['msg']['selfOrigin']
            if origin:
                outroutes.append(entry)
        if not outroutes:
            return routes
        else:
            return outroutes

    def get_origin_routes(self, routes):
        """ select origin routes: IGP > EGP > UNK """
        igpList = []
        egpList = []
        unkList = []
        outroutes = []
        for entry in routes:
            originRoute = entry['msg']['origin']
            if originRoute == "IGP":
                igpList.append(entry)
            elif originRoute == "EGP":
                egpList.append(entry)
            elif originRoute == "UNK":
                unkList.append(entry)

        if igpList:
            outroutes = igpList
        elif egpList:
            outroutes = egpList
        elif unkList:
            outroutes = unkList

        return outroutes

    def lowest_ip(self, routes):
        """ return the neighbor router (i.e. the "src" of the update message) with the lowest IP address """
        outroutes = []
        # {'src' of entry : entry }
        iplist = {}
        # {'src' of entry in number form : entry }
        ipvlist = {}
        for entry in routes:
            iplist[entry['peer']] = entry

        for r in iplist.keys():
            ipnum = ipToValue(r)
            ipvlist[ipnum] = ipl[r]

        minipv = min(ipvlist.keys())
        for m in ipvlist.keys():
            if minipv == m:
                outroutes.append(ipvlist[m])
        return outroutes

    def filter_relationships(self, srcif, routes):
        """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
        outroutes = []
        source = self.relations[srcif]
        if source == "cust":
            outroutes = routes
        else:
            for entry in routes:
                dest = entry['type']
                if dest == "cust":
                    outroutes.append(entry)
        return outroutes

    def get_route(self, srcif, daddr, routes):
        """	Select the best route for a given address	"""
        peer = None
        # Rules go here
        if routes:
            # 1. Highest Preference
            routes = self.get_highest_preference(routes)
            # 2. Self Origin
            routes = self.get_self_origin(routes)
            # 3. Shortest ASPath
            routes = self.get_shortest_as_path(routes)
            # 4. EGP > IGP > UNK
            routes = self.get_origin_routes(routes)
            # 5. Lowest IP Address
            routes = self.lowest_ip(routes)
            # Final check: enforce peering relationships
            routes = self.filter_relationships(srcif, routes)

        # return the peer to send the msg through, else return nothing
        if len(routes) == 0:
            return None
        else:
            return routes[0]
        # return self.sockets[peer] if peer else None

    def longest_prefix(self, routes):
        # count netmasks of each route
        outroutes = []
        # {length of netmask : corresponding forwarding table entry}
        nmCounts = {}
        for entry in routes:
            nmlen = countNetmask(entry['netmask'])
            nmCounts[nmlen] = entry
        # find max netmask = maxNM
        maxNM = max(nmCounts.keys())
        # return list of routes with that maxNM
        for nm in nmCounts:
            if nm == maxNM:
                outroutes.append(nmCounts[nm])
        return outroutes

    # sends a no route msg to src of packet
    def send_no_route(self, packet):
        my_ip = neighborToRouterIP(packet['src'])
        datapkg = {"src": my_ip, "dst": packet['src'], "type": "no route", "msg": {}}
        datapkgb = dictToByte(datapkg)
        self.sockets[packet['src']].sendall(datapkgb)

    def send_one_route(self, packet, route):
        my_ip = neighborToRouterIP(route['peer'])
        datapkg = {"src": packet['src'], "dst": packet['dst'], "type": "data", "msg": packet['msg']}
        datapkgb = dictToByte(datapkg)
        self.sockets[route['peer']].sendall(datapkgb)

    def broadcast(self, announcement, packet):
        srcType = self.relations[packet['src']]
        if srcType == "cust":
            for n in self.sockets.keys():
                if packet['src'] != n:
                    # creates appropriate python address for announcement source
                    dest = neighborToRouterIP(n)
                    # sets the correct values for announcement src, dst, and ancts
                    announcement['src'] = dest
                    announcement['dst'] = n
                    # print("ANNOUNCEMENT: ", announcement)
                    ancts = json.dumps(announcement)
                    anctb = ancts.encode('utf-8')
                    self.sockets[n].sendall(anctb)
        else:
            for r in self.relations.keys():
                if packet['src'] != r and (self.relations[r] == "peer" or self.relations[r] == "prov"):
                    # creates appropriate python address for announcement source
                    dest = neighborToRouterIP(r)
                    # sets the correct values for announcement src, dst, and ancts
                    announcement['src'] = dest
                    announcement['dst'] = r
                    # print("ANNOUNCEMENT: ", announcement)
                    ancts = json.dumps(announcement)
                    anctb = ancts.encode('utf-8')
                    self.sockets[r].sendall(anctb)

    def forward(self, srcif, packet):
        """	Forward a data packet	"""
        # lookup all valid routes for an address
        routes = self.lookup_routes(packet['dst'])
        numRoutes = len(routes)

        # Scenario 1: no route => send a "no route" msg back to the src of the data packet
        if numRoutes == 0:
            self.send_no_route(packet)
        # Scenario 2 - 4
        elif numRoutes >= 1:
            daddr = packet['dst']
            # Scenario 2: one possible route
            if numRoutes == 1:
                route = routes[0]
                self.send_one_route(packet, route)
            elif numRoutes > 1:
                routes = self.longest_prefix(routes)
                numRoutes = len(routes)
                # Scenario 3: longest prefix
                if numRoutes == 1:
                    # if longest prefix returned only one route, make that the route to take
                    route = routes[0]
                    self.send_one_route(packet, route)
                # Scenario 4: tie breakers
                elif numRoutes > 1:
                    # if not, then go to get_route to apply the tie-breaker rules
                    route = self.get_route(srcif, daddr, routes)
                    if not route:
                        self.send_no_route(packet)
                    else:
                        self.send_one_route(packet, route)

        return False

    def coalesce(self):
        """	coalesce any routes that are right next to each other	"""
        # TODO (this is the most difficult task, save until last)
        return False

    def update(self, srcif, packet):
        """	handle update packets	"""
        # adds entry to forwarding table (updates)
        entry = {"network": packet['msg']['network'], "netmask": packet['msg']['netmask'], "peer": packet['src'],
                 'localPref': packet['msg']['localpref'], 'origin': packet['msg']['origin'],
                 'selfOrigin': packet['msg']['selfOrigin']}

        forwarding_table.append(entry)
        self.updates.append(packet)
        announcement = {"src": "", "dst": "", "type": "update",
                        "msg": {"network": packet['msg']['network'], "netmask": packet['msg']['netmask'],
                                "localpref": packet['msg']['localpref'], "ASPath": [],
                                "origin": packet['msg']['origin'], "selfOrigin": packet['msg']['selfOrigin']}}
        for a in packet['msg']['ASPath']:
            announcement['msg']['ASPath'].append(a)

        announcement['msg']['ASPath'].append(args.asn)
        # print("PACKET: ", packet)
        self.broadcast(announcement, packet)
        return False

    def revoke(self, packet):
        """	handle revoke packets """
        msg = packet['msg']
        self.remove_entries(msg)
        announcement = {"src": "", "dst": "", "type": "revoke",
                        "msg": msg}
        self.broadcast(announcement, packet)
        return True

    def dump(self, packet):
        """	handles dump table requests	"""
        print("DUMPING")
        dumppkg = {'src': packet['dst'], 'dst': packet['src'], 'type': 'table', 'msg': forwarding_table}
        dumppkgb = dictToByte(dumppkg)
        print(packet['src'])
        print(forwarding_table)
        self.sockets[packet['src']].sendall(dumppkgb)
        return True

    def handle_packet(self, srcif, packet):
        """	dispatches a packet """
        # TODO
        return False

    def send_error(self, conn, msg):
        """ Send a no_route error message """
        # TODO
        return

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                try:
                    k = conn.recv(65535)
                except:
                    # either died on a connection reset, or was SIGTERM's by parent
                    return
                if k:
                    for sock in self.sockets:
                        if self.sockets[sock] == conn:
                            srcif = sock
                    msg = json.loads(k)
                    message = {"type": msg['type'], "dst": msg['dst'], "src": msg['src'], "msg": msg['msg']}
                    messages.append(message)
                    if message['type'] == 'update':
                        self.update(srcif, msg)
                    if message['type'] == 'data':
                        self.forward(srcif, msg)
                    if message['type'] == 'dump':
                        self.dump(msg)
                    if message['type'] == 'revoke':
                        self.revoke(msg)
                    if not self.handle_packet(srcif, msg):
                        self.send_error(conn, msg)
                else:
                    return
                print(messages)


if __name__ == "__main__":
    router = Router(args.networks)
    router.run()
