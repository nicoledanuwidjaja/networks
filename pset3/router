#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, math

#DEBUG = True
DEBUG = False

parser = argparse.ArgumentParser(description='route packets')
parser.add_argument('asn', type=int, help="AS Number")
parser.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
args = parser.parse_args()

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"

# received incoming data
messages = []
forwarding_table = []

##########################################################################################

# UTILITY FUNCTIONS
# convert ip address to binary representation of four 8-bit segments
def binl(ip):   
    ipl = ip.split(".")
    binl = []
    for n in ipl:
        # turn into binary
        binip = bin(int(n))[2:]
        # add padding for 8-bit segments
        strip = str(binip).zfill(8)
        binl.append(strip)
    return binl 

# calculate the combination for network/netmask addresses
def combine_submask(netmask_ip, dest_ip):
    #print("OG Netmask: ", netmask_ip)
    #print("OG Dest: ", dest_ip)
    combined = []
    # separate bits into four groups of 8-bits
    for b in range(4):
        # calculate bitwise and for each bit individually
        finpart = ""
        for s in range(8):
            finpart += str(int(netmask_ip[b][s]) & int(dest_ip[b][s]))
        #print("Part: ", finpart)
        combined.append(finpart)
    #print("Combined: ", combined)
    return combined

# match combined network/netmask addresses with corresponding neighbor network
def mask(dest):
    result = []
    # fake = ["192.168.0.0"]
    for e in forwarding_table:
        nmbinl = binl(e['netmask'])
        destbinl = binl(dest)
        # Test variables
        # nmbinl = binl("192.168.0.0")
        # destbinl = binl("255.255.255.0")
        subresult = combine_submask(nmbinl, destbinl)
        result.append(subresult)
    return result

# convert list of binary ips(in list form) to list of dec ips (in list form)
def ipl(binl):
    ipl = []
    for b in range(len(binl)):
        binp = []
        for p in range(4):
            binp.append(int(binl[b][p], 2))
        ipl.append(binp)
    return ipl

# see if a specific network matches a 
# specific destination that has already been masked
def matchIps(networkipl, destipl):
    for i in range(4):
        if (networkipl[i] == 0):
            return True
        elif (networkipl[i] != destipl[i]):
            return False

# find the network in the forwarding table that can route
# the given destination
def findDest(result):
    resultdec = ipl(result)
    valid_entries = []
    for i in range(len(result)):
        ftipl = forwarding_table[i]['network'].split('.')
        #print("RESULT IPL: ", resultdec[i])
        #print("FT IPL: ", ftipl)
        if matchIps(strToIntl(ftipl), resultdec[i]):
            valid_entries.append(i)
    return valid_entries    

def dictToByte(dictionary):
    dictj = json.dumps(dictionary)
    dictb = dictj.encode("utf-8")
    return dictb

def strToIntl(strl):
    intl = []
    for s in strl:
        intl.append(int(s))
    return intl

class Router:

    routes = None
    updates = None
    relations = None
    sockets = None

    def __init__(self, networks):
        self.routes = []
        self.updates = []
        self.relations = {}
        self.sockets = {}
        for relationship in networks:
            # ip address and type (customer, provider, peer)
            network, relation = relationship.split("-")
            if DEBUG: 
                print("Starting socket for", network, relation)
            self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sockets[network].setblocking(0)
            self.sockets[network].connect(network)
            self.relations[network] = relation
        return
           
    def lookup_routes(self, daddr):
        """ Lookup all valid routes for an address """
        # TODO
        outroutes = []
        return outroutes

    def get_shortest_as_path(self, routes):
        """ select the route with the shortest AS Path """
        # TODO
        outroutes = []
        return outroutes
            
    def get_highest_preference(self, routes):
        """ select the route with the shortest AS Path """
        # TODO
        outroutes = []
        return outroutes
         
    def get_self_origin(self, routes):
        """ select self originating routes """
        # TODO
        outroutes = []
        return outroutes

    def get_origin_routes(self, routes):
        """ select origin routes: EGP > IGP > UNK """
        # TODO
        outroutes = []
        return outroutes

    def filter_relationships(self, srcif, routes):
        """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
        outroutes = []
        return outroutes

    def get_route(self, srcif, daddr):
        """	Select the best route for a given address	"""
        # TODO
        peer = None
        routes = lookup_routers(daddr)
        # Rules go here
        if routes:
            # 1. Highest Preference
            routes = self.get_highest_preference(routes)
            # 2. Self Origin
            routes = self.get_self_origin(routes)
            # 3. Shortest ASPath
            routes = self.get_shortest_as_path(routes)
            # 4. EGP > IGP > UNK
            routes = self.get_origin_routes(routes)
            # 5. Lowest IP Address
            # TODO
            # Final check: enforce peering relationships
            routes = self.filter_relationships(srcif, routes)
        return self.sockets[peer] if peer else None

    def forward(self, srcif, packet):
        """	Forward a data packet	"""
        port = mask(packet['dst'])
        portipl = ipl(port)
        #print(portipl)
        valid_entries = findDest(port)
        #print(packet)
        # Scenario 1: no route
        if (len(valid_entries) == 0):
            #print("NO VALID ENTRIES")
            my_ip = '.'.join(packet['src'].split('.')[:-1]+["1"])
            datapkg = {"src": my_ip, "dst": packet['src'], "type": "no route", "msg": {}}
            datapkgb = dictToByte(datapkg)
            self.sockets[packet['src']].sendall(datapkgb)
        # Scenario 2: one possible route
        elif (len(valid_entries) == 1):
            valid_entry = forwarding_table[valid_entries[0]]
            #print(valid_entry)
            my_ip = '.'.join(valid_entry['peer'].split('.')[:-1]+["1"])
            datapkg = {"src": packet['src'], "dst": packet['dst'], "type": "data", "msg":packet['msg']}
            datapkgb = dictToByte(datapkg)
            self.sockets[valid_entry['peer']].sendall(datapkgb)
        # Scenario 3: multiple possible routes
        # Scenario 4: tie breaker needed
        return False

    def coalesce(self):
        """	coalesce any routes that are right next to each other	"""
        # TODO (this is the most difficult task, save until last)
        return False

    def update(self, srcif, packet):
        """	handle update packets	"""
        # adds entry to forwarding table (updates)
        entry = {"network": packet['msg']['network'], "netmask": packet['msg']['netmask'], "peer": packet['src']}
        
        forwarding_table.append(entry)
        self.updates.append(packet)
        announcement = {"type": "update", "src": "", "dst": "", "msg": {"network": packet['msg']['network'], "netmask": packet['msg']['netmask'], "localpref": packet['msg']['localpref'], "ASPath": [], "origin": packet['msg']['origin'], "selfOrigin": packet['msg']['selfOrigin']}}
        for a in packet['msg']['ASPath']:
            announcement['msg']['ASPath'].append(a)
        
        announcement['msg']['ASPath'].append(args.asn)    
        #print("PACKET: ", packet)
        for n in self.sockets.keys():
            if packet['src'] != n:
                # creates appropriate python address for announcement source
                dest = '.'.join(n.split('.')[:-1]+["1"])
                # sets the correct values for announcement src, dst, and ancts
                announcement['src'] = dest
                announcement['dst'] = n
                #print("ANNOUNCEMENT: ", announcement)
                ancts = json.dumps(announcement)
                anctb = ancts.encode('utf-8')
                self.sockets[n].sendall(anctb)
        
        #print("Updates: ", self.updates)
        #print("Entry: ", entry)
        return False
    
    def revoke(self, packet):
        """	handle revoke packets	"""
        # TODO
        return True

    def dump(self, packet):
        """	handles dump table requests	"""
        print("DUMPING")
        dumppkg = { 'src': packet['dst'], 'dst': packet['src'], 'type': 'table', 'msg': forwarding_table}
        dumppkgb = dictToByte(dumppkg)
        print(packet['src'])
        print(forwarding_table)
        self.sockets[packet['src']].sendall(dumppkgb)
        return True

    def handle_packet(self, srcif, packet):
        """	dispatches a packet """
        # TODO
        return False

    def send_error(self, conn, msg):
        """ Send a no_route error message """
        # TODO
        return

    def run(self):
        while True:
            # opens and listens to Unix domain sockets
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                try:
                    k = conn.recv(65535)
                except:
                    # either died on a connection reset, or was SIGTERM's by parent
                    return
                if k:
                    for sock in self.sockets:
                        if self.sockets[sock] == conn:
                            # source interface: source port/socket of data message
                            srcif = sock
                    msg = json.loads(k)
                    message = {"type": msg['type'], "dst": msg['dst'], "src": msg['src'], "msg": msg['msg']}
                    messages.append(message)
                    if message['type'] == 'update':
                        self.update(srcif, msg)
                    if message['type'] == 'data':
                        self.forward(srcif, msg)
                    if message['type'] == 'dump':
                        self.dump(msg)
                    if not self.handle_packet(srcif, msg):
                        self.send_error(conn, msg)
                else:
                    return
                #print(messages)
        return

if __name__ == "__main__":
    router = Router(args.networks)
    router.run()
