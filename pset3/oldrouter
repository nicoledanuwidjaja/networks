#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, math

# DEBUG = True
DEBUG = False

parser = argparse.ArgumentParser(description='route packets')
parser.add_argument('asn', type=int, help="AS Number")
parser.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
args = parser.parse_args()

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"

# received incoming data
messages = []
forwarding_table = []


##########################################################################################

# UTILITY FUNCTIONS
# convert ip address to binary representation of four 8-bit segments
def binl(ip):
    ipl = ip.split(".")
    binl = []
    for n in ipl:
        # turn into binary
        binip = bin(int(n))[2:]
        # add padding for 8-bit segments
        strip = str(binip).zfill(8)
        binl.append(strip)
    return binl


# calculate the combination for network/netmask addresses
def combine_submask(netmask_ip, dest_ip):
    # print("OG Netmask: ", netmask_ip)
    # print("OG Dest: ", dest_ip)
    combined = []
    # separate bits into four groups of 8-bits
    for b in range(4):
        # calculate bitwise and for each bit individually
        finpart = ""
        for s in range(8):
            finpart += str(int(netmask_ip[b][s]) & int(dest_ip[b][s]))
        # print("Part: ", finpart)
        combined.append(finpart)
    # print("Combined: ", combined)
    return combined


# match combined network/netmask addresses with corresponding neighbor network
def mask(dest):
    result = []
    # fake = ["192.168.0.0"]
    for e in forwarding_table:
        nmbinl = binl(e['netmask'])
        destbinl = binl(dest)
        # Test variables
        # nmbinl = binl("192.168.0.0")
        # destbinl = binl("255.255.255.0")
        subresult = combine_submask(nmbinl, destbinl)
        result.append(subresult)
    return result


# convert list of binary ips(in list form) to list of dec ips (in list form)
def ipl(binl):
    ipl = []
    for b in range(len(binl)):
        binp = []
        for p in range(4):
            binp.append(int(binl[b][p], 2))
        ipl.append(binp)
    return ipl


# see if a specific network matches a
# specific destination that has already been masked
def matchIps(networkipl, destipl):
    for i in range(4):
        if networkipl[i] == 0:
            return True
        elif networkipl[i] != destipl[i]:
            return False


# encodes dictionary as bytes in json format
def dictToByte(dictionary):
    dictj = json.dumps(dictionary)
    dictb = dictj.encode("utf-8")
    return dictb


# converts ip address string to integer list of size four
def ipToIntList(strl):
    return list(map(int, strl.split('.')))


def ipToValue(ipl):
    return int("".join(ipl))


# convert ip of neighbor to oldrouter (*.*.*.2 to *.*.*.1)
def neighborToRouterIP(neighbor):
    return '.'.join(neighbor.split('.')[:-1] + ["1"])


# returns the length of the netmask
def countNetmask(nmstr):
    nmBin = binl(nmstr)
    count = 0
    for x in range(len(nmBin)):
        for y in nmBin[x]:
            if int(y) == 1:
                count += 1
    return count


# count number of duplicates of the max number
def checkForDups(nmlist):
    maxnm = max(nmlist)
    count = 0
    for l in nmlist:
        if l == maxnm:
            count += 1
    return count


# returns dictionary of length of netmask and index in forwarding table of all valid routes
def netmaskCounts(valid_entries):
    nmCounts = {}
    for idx in range(len(valid_entries)):
        nmlen = countNetmask(forwarding_table[idx]['netmask'])
        nmCounts[idx] = nmlen
    return nmCounts


def get_key(val, dictionary):
    print(dictionary)
    for key, value in dictionary.items():
        print("val: ", value)
        print("key: ", key)
        if val == value:
            return key
    return "key doesnt exist"


class Router:
    routes = None
    updates = None
    relations = None
    sockets = None

    def __init__(self, networks):
        self.routes = []
        self.updates = []
        self.relations = {}
        self.sockets = {}
        for relationship in networks:
            # ip address and type (customer, provider, peer)
            network, relation = relationship.split("-")
            if DEBUG:
                print("Starting socket for", network, relation)
            self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sockets[network].setblocking(0)
            self.sockets[network].connect(network)
            self.relations[network] = relation
        return

    # find the networks in the forwarding table that can route
    # the given destination
    def lookup_routes(self, daddr):
        """ Lookup all valid routes for an address """
        port = mask(daddr)
        resultdec = ipl(port)
        valid_entries = []
        for i in range(len(port)):
            ipstr = forwarding_table[i]['network']
            # print("RESULT IPL: ", resultdec[i])
            # print("FT IPL: ", ftipl)
            if matchIps(ipToIntList(ipstr), resultdec[i]):
                valid_entries.append(i)
        return valid_entries

    def get_shortest_as_path(self, routes):
        """ select the route with the shortest AS Path """
        outroutes = []
        pathCounts = {}
        for routeIdx in routes:
            currPathLength = len(forwarding_table[routeIdx]['msg']['ASPath'])
            pathCounts[currPathLength] = routeIdx
        minPath = min(pathCounts.keys())

        for pathLength, ASPath in pathCounts.items():
            if pathLength == minPath:
                outroutes.append(pathLength)
        return outroutes

    def get_highest_preference(self, routes):
        """ select the route with the highest localpref """
        outroutes = []
        prefRoutes = {}
        for routeIdx in routes:
            localPref = forwarding_table[routeIdx]['msg']['localpref']
            prefRoutes[localPref] = routeIdx
        highestPref = max(prefRoutes.keys())

        for routePref, localpref in prefRoutes.items():
            if routePref == highestPref:
                outroutes.append(routePref)
        return outroutes

    def get_self_origin(self, routes):
        """ select self originating routes """
        outroutes = []
        for routeIdx in routes:
            origin = forwarding_table[routeIdx]['msg']['selfOrigin']
            if origin:
                outroutes.append(routeIdx)

        if not outroutes:
            return routes
        else:
            return outroutes

    def get_origin_routes(self, routes):
        """ select origin routes: IGP > EGP > UNK """
        igpList = []
        egpList = []
        unkList = []
        outroutes = []
        for routeIdx in routes:
            originRoute = forwarding_table[routeIdx]['msg']['origin']
            if originRoute == "IGP":
                igpList.append(routeIdx)
            elif originRoute == "EGP":
                egpList.append(routeIdx)
            elif originRoute == "UNK":
                unkList.append(routeIdx)

        if igpList:
            outroutes = igpList
        elif egpList:
            outroutes = egpList
        elif unkList:
            outroutes = unkList

        return outroutes

    def filter_relationships(self, srcif, routes):
        """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
        outroutes = []
        source = self.relations[srcif]
        if source == "cust":
            outroutes = routes
        else:
            for r in routes:
                dest = forwarding_table[r]['type']
                if dest == "cust":
                    outroutes.append(r)
        return outroutes

    def get_route(self, srcif, daddr):
        """	Select the best route for a given address	"""
        # peer = None
        routes = self.lookup_routes(daddr)
        nmCounts = netmaskCounts(routes)
        dups = checkForDups(nmCounts.keys())
        # Rules go here
        if dups > 1:
            # Scenario 4
            # 1. Highest Preference
            routes = self.get_highest_preference(routes)
            # 2. Self Origin
            routes = self.get_self_origin(routes)
            # 3. Shortest ASPath
            routes = self.get_shortest_as_path(routes)
            # 4. EGP > IGP > UNK
            routes = self.get_origin_routes(routes)
            # 5. Lowest IP Address
            ipl = {}
            ipvlist = {}
            newRoutes = []
            for r in routes:
                ipl.append(forwarding_table[r]['src'], r)
            for i in ipl.keys():
                ipnum = ipToValue(i)
                ipvlist[ipnum] = ipl[i]
            minipv = min(ipvlist.keys())
            for m in ipvlist.keys():
                if minipv == m:
                    newRoutes.append(ipvlist[m])

            # Final check: enforce peering relationships
            return self.filter_relationships(srcif, routes)
        else:
            # Scenario 3
            return routes
            # my_ip = neighborToRouterIP(nmCounts[maxnm])
        # return self.sockets[peer] if peer else None

    def forward(self, srcif, packet):
        """	Forward a data packet	"""
        # print(portipl)
        valid_entries = self.lookup_routes(packet['dst'])
        # print(packet)
        # Scenario 1: no route
        if len(valid_entries) == 0:
            # print("NO VALID ENTRIES")
            my_ip = neighborToRouterIP(packet['src'])
            datapkg = {"src": my_ip, "dst": packet['src'], "type": "no route", "msg": {}}
            datapkgb = dictToByte(datapkg)
            self.sockets[packet['src']].sendall(datapkgb)
        # Scenario 2: one possible route
        elif len(valid_entries) == 1:
            valid_entry = forwarding_table[valid_entries[0]]
            # print(valid_entry)
            my_ip = neighborToRouterIP(valid_entry['peer'])
            datapkg = {"src": packet['src'], "dst": packet['dst'], "type": "data", "msg": packet['msg']}
            datapkgb = dictToByte(datapkg)
            self.sockets[valid_entry['peer']].sendall(datapkgb)
        # Scenario 3: multiple possible routes
        elif len(valid_entries) > 1:
            routes = self.get_route(srcif, packet['dst'])
            nmCounts = netmaskCounts(self.routes)
            maxnm = max(nmCounts.values())
            if not routes:
                my_ip = neighborToRouterIP(packet['src'])
                datapkg = {"src": my_ip, "dst": packet['src'], "type": "no route", "msg": {}}
            else:
                table_entry = forwarding_table[routes[0]]
                my_ip = neighborToRouterIP(table_entry['peer'])
                print(my_ip)
                datapkg = {"src": packet['src'], "dst": packet['dst'], "type": "data", "msg": packet['msg']}
            datapkgb = dictToByte(datapkg)
            self.sockets[forwarding_table[routes[get_key(maxnm, nmCounts)]]['peer']].sendall(datapkgb)

        # Scenario 4: tie breaker needed
        return False

    def coalesce(self):
        """	coalesce any routes that are right next to each other	"""
        # TODO (this is the most difficult task, save until last)
        return False

    def update(self, srcif, packet):
        """	handle update packets	"""
        # adds entry to forwarding table (updates)
        entry = {"network": packet['msg']['network'], "netmask": packet['msg']['netmask'], "peer": packet['src'],
                 'localPref': packet['msg']['localpref'], 'origin': packet['msg']['origin'],
                 'selfOrigin': packet['msg']['selfOrigin']}

        forwarding_table.append(entry)
        self.updates.append(packet)
        announcement = {"type": "update", "src": "", "dst": "",
                        "msg": {"network": packet['msg']['network'], "netmask": packet['msg']['netmask'],
                                "localpref": packet['msg']['localpref'], "ASPath": [],
                                "origin": packet['msg']['origin'], "selfOrigin": packet['msg']['selfOrigin']}}
        for a in packet['msg']['ASPath']:
            announcement['msg']['ASPath'].append(a)

        announcement['msg']['ASPath'].append(args.asn)
        # print("PACKET: ", packet)
        srcType = self.relations[packet['src']]
        if srcType == "cust":
            for n in self.sockets.keys():
                if packet['src'] != n:
                    # creates appropriate python address for announcement source
                    dest = neighborToRouterIP(n)
                    # sets the correct values for announcement src, dst, and ancts
                    announcement['src'] = dest
                    announcement['dst'] = n
                    # print("ANNOUNCEMENT: ", announcement)
                    ancts = json.dumps(announcement)
                    anctb = ancts.encode('utf-8')
                    self.sockets[n].sendall(anctb)
        else:
            for r in self.relations.keys():
                if packet['src'] != r and (self.relations[r] == "peer" or self.relations[r] == "prov"):
                    # creates appropriate python address for announcement source
                    dest = neighborToRouterIP(r)
                    # sets the correct values for announcement src, dst, and ancts
                    announcement['src'] = dest
                    announcement['dst'] = r
                    # print("ANNOUNCEMENT: ", announcement)
                    ancts = json.dumps(announcement)
                    anctb = ancts.encode('utf-8')
                    self.sockets[r].sendall(anctb)

        # print("Updates: ", self.updates)
        # print("Entry: ", entry)
        return False

    def revoke(self, packet):
        """	handle revoke packets	"""
        # TODO
        return True

    def dump(self, packet):
        """	handles dump table requests	"""
        print("DUMPING")
        dumppkg = {'src': packet['dst'], 'dst': packet['src'], 'type': 'table', 'msg': forwarding_table}
        dumppkgb = dictToByte(dumppkg)
        print(packet['src'])
        print(forwarding_table)
        self.sockets[packet['src']].sendall(dumppkgb)
        return True

    def handle_packet(self, srcif, packet):
        """	dispatches a packet """
        # TODO
        return False

    def send_error(self, conn, msg):
        """ Send a no_route error message """
        # TODO
        return

    def run(self):
        while True:
            # opens and listens to Unix domain sockets
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                try:
                    k = conn.recv(65535)
                except:
                    # either died on a connection reset, or was SIGTERM's by parent
                    return
                if k:
                    for sock in self.sockets:
                        if self.sockets[sock] == conn:
                            # source interface: source port/socket of data message
                            srcif = sock
                    msg = json.loads(k)
                    message = {"type": msg['type'], "dst": msg['dst'], "src": msg['src'], "msg": msg['msg']}
                    messages.append(message)
                    if message['type'] == 'update':
                        self.update(srcif, msg)
                    if message['type'] == 'data':
                        self.forward(srcif, msg)
                    if message['type'] == 'dump':
                        self.dump(msg)
                    if not self.handle_packet(srcif, msg):
                        self.send_error(conn, msg)
                else:
                    return
                # print(messages)
        return


if __name__ == "__main__":
    router = Router(args.networks)
    router.run()
